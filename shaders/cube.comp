#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba8) uniform writeonly image2D destImage;

layout(std140, binding = 1) uniform Camera {
    vec4 camPos;
    vec4 camForward;
    vec4 camRight;
    vec4 camUp;
    vec4 params;
} camera;

const int UPSCALE = 1;
const float HIT_EPS = 1e-3;
const int MAX_STEPS = 256;
const float MAX_DIST = 200.0;
const ivec3 VOXELS[6] = ivec3[6](
    ivec3(0, 0, 0),
    ivec3(1, 0, 0),
    ivec3(-1, 0, 0),
    ivec3(0, 0, 1),
    ivec3(0, 0, -1),
    ivec3(0, 1, 0)
);
const vec3 VOXEL_COLORS[6] = vec3[6](
    vec3(0.9, 0.55, 0.25),
    vec3(0.25, 0.6, 0.9),
    vec3(0.85, 0.25, 0.35),
    vec3(0.3, 0.8, 0.4),
    vec3(0.65, 0.6, 0.2),
    vec3(0.8, 0.35, 0.75)
);

vec3 safeNorm(vec3 v) {
    float l = length(v);
    return l > 1e-5 ? v / l : vec3(0.0, 0.0, -1.0);
}

int blockIndex(ivec3 cell) {
    for (int i = 0; i < VOXELS.length(); ++i) {
        if (all(equal(cell, VOXELS[i]))) return i;
    }
    return -1;
}

bool traceVoxel(vec3 ro, vec3 rd, out vec3 hitPos, out vec3 hitN, out float dist, out int mat) {
    ivec3 cell = ivec3(floor(ro));
    ivec3 istep = ivec3(rd.x > 0.0 ? 1 : -1, rd.y > 0.0 ? 1 : -1, rd.z > 0.0 ? 1 : -1);
    
    vec3 tDelta = vec3(1e30);
    vec3 tMax = vec3(1e30);
    
    if (abs(rd.x) > 1e-6) {
        tDelta.x = abs(1.0 / rd.x);
        tMax.x = (istep.x > 0) ? (float(cell.x + 1) - ro.x) / rd.x : (float(cell.x) - ro.x) / rd.x;
    }
    if (abs(rd.y) > 1e-6) {
        tDelta.y = abs(1.0 / rd.y);
        tMax.y = (istep.y > 0) ? (float(cell.y + 1) - ro.y) / rd.y : (float(cell.y) - ro.y) / rd.y;
    }
    if (abs(rd.z) > 1e-6) {
        tDelta.z = abs(1.0 / rd.z);
        tMax.z = (istep.z > 0) ? (float(cell.z + 1) - ro.z) / rd.z : (float(cell.z) - ro.z) / rd.z;
    }
    
    int lastAxis = -1;
    float tCur = 0.0;

    for (int i = 0; i < MAX_STEPS; ++i) {
        int idx = blockIndex(cell);
        if (idx >= 0) {
            if (lastAxis == 0) hitN = vec3(-float(istep.x), 0.0, 0.0);
            else if (lastAxis == 1) hitN = vec3(0.0, -float(istep.y), 0.0);
            else if (lastAxis == 2) hitN = vec3(0.0, 0.0, -float(istep.z));
            else hitN = -rd;
            hitPos = ro + rd * tCur;
            dist = tCur;
            mat = idx;
            return true;
        }

        if (tMax.x < tMax.y) {
            if (tMax.x < tMax.z) {
                tCur = tMax.x;
                tMax.x += tDelta.x;
                cell.x += istep.x;
                lastAxis = 0;
            } else {
                tCur = tMax.z;
                tMax.z += tDelta.z;
                cell.z += istep.z;
                lastAxis = 2;
            }
        } else {
            if (tMax.y < tMax.z) {
                tCur = tMax.y;
                tMax.y += tDelta.y;
                cell.y += istep.y;
                lastAxis = 1;
            } else {
                tCur = tMax.z;
                tMax.z += tDelta.z;
                cell.z += istep.z;
                lastAxis = 2;
            }
        }
        
        if (tCur > MAX_DIST) break;
    }
    return false;
}

vec3 shade(vec3 ro, vec3 rd, vec2 uv) {
    vec3 hitPos;
    vec3 hitN;
    float t;
    int m;
    vec3 sky = mix(vec3(0.12, 0.18, 0.28), vec3(0.04, 0.05, 0.08), clamp(uv.y * 0.5 + 0.5, 0.0, 1.0));
    if (!traceVoxel(ro, rd, hitPos, hitN, t, m)) return sky;
    vec3 lightDir = safeNorm(vec3(0.6, 0.9, 0.3));
    float diff = max(dot(hitN, lightDir), 0.0);
    vec3 base = VOXEL_COLORS[m];
    float fog = clamp(t / MAX_DIST, 0.0, 1.0);
    vec3 lit = base * (0.25 + 0.75 * diff);
    return mix(lit, sky, fog);
}

void main() {
    ivec2 fullSize = imageSize(destImage);
    ivec2 lowSize = fullSize / UPSCALE;
    ivec2 pixelLow = ivec2(gl_GlobalInvocationID.xy);
    if (pixelLow.x >= lowSize.x || pixelLow.y >= lowSize.y) return;

    vec2 uv = (vec2(pixelLow * UPSCALE) + 0.5 * float(UPSCALE)) / vec2(fullSize) * 2.0 - 1.0;

    float fov = camera.params.x;
    if (fov <= 0.0) fov = 1.0471976;
    float aspect = camera.params.y;
    if (aspect <= 0.0) aspect = float(fullSize.x) / float(fullSize.y);
    float tanHalfFov = tan(0.5 * fov);
    uv.x *= aspect;

    vec3 f = safeNorm(camera.camForward.xyz);
    vec3 r = safeNorm(camera.camRight.xyz);
    vec3 u = safeNorm(camera.camUp.xyz);
    r = -r;
    u = -u;

    vec3 rayDir = normalize(f + uv.x * tanHalfFov * r + uv.y * tanHalfFov * u);
    vec3 rayOrigin = camera.camPos.xyz;

    vec3 color = shade(rayOrigin, rayDir, uv);

    for (int oy = 0; oy < UPSCALE; ++oy) {
        for (int ox = 0; ox < UPSCALE; ++ox) {
            ivec2 dst = ivec2(pixelLow.x * UPSCALE + ox, pixelLow.y * UPSCALE + oy);
            if (dst.x < fullSize.x && dst.y < fullSize.y) {
                imageStore(destImage, dst, vec4(color, 1.0));
            }
        }
    }
}

