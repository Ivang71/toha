#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba8) uniform writeonly image2D destImage;

layout(std140, binding = 1) uniform Camera {
    vec4 camPos;
    vec4 camForward;
    vec4 camRight;
    vec4 camUp;
    vec4 params;
} camera;

const int UPSCALE = 2;
const float HIT_EPS = 1e-3;
const int MAX_STEPS = 512;
const float MAX_DIST = 500.0;
const int MAT_AIR = -1;
const int MAT_GRASS = 0;
const int MAT_DIRT = 1;
const int MAT_STONE = 2;

float hash11(float p) {
    p = fract(p * 0.1031);
    p *= p + 33.33;
    p *= p + p;
    return fract(p);
}

float simplex3(vec3 v) {
    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);
    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
    vec3 i = floor(v + dot(v, C.yyy));
    vec3 x0 = v - i + dot(i, C.xxx);
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min(g, l.zxy);
    vec3 i2 = max(g, l.zxy);
    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy;
    vec3 x3 = x0 - D.yyy;
    i = mod(i, 289.0);
    vec4 p = mod((vec4(i.z) + vec4(0.0, i1.z, i2.z, 1.0)) * 34.0 + 1.0, 289.0);
    p = mod((p + vec4(i.y) + vec4(0.0, i1.y, i2.y, 1.0)) * 34.0 + 1.0, 289.0);
    p = mod((p + vec4(i.x) + vec4(0.0, i1.x, i2.x, 1.0)) * 34.0 + 1.0, 289.0);
    vec4 j = p - 289.0 * floor(p / 289.0);
    float inv7 = 1.0 / 7.0;
    vec4 x_ = floor(j * inv7);
    vec4 y_ = floor(j - 7.0 * x_);
    vec4 x = x_ * C.x + C.yyyy;
    vec4 y = y_ * C.x + C.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);
    vec4 b0 = vec4(x.xy, y.xy);
    vec4 b1 = vec4(x.zw, y.zw);
    vec4 s0 = floor(b0) * 2.0 + 1.0;
    vec4 s1 = floor(b1) * 2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));
    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
    vec3 g0 = vec3(a0.xy, h.x);
    vec3 g1 = vec3(a0.zw, h.y);
    vec3 g2 = vec3(a1.xy, h.z);
    vec3 g3 = vec3(a1.zw, h.w);
    vec4 norm = inversesqrt(vec4(dot(g0, g0), dot(g1, g1), dot(g2, g2), dot(g3, g3)));
    g0 *= norm.x;
    g1 *= norm.y;
    g2 *= norm.z;
    g3 *= norm.w;
    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
    m = m * m;
    return 42.0 * dot(m * m, vec4(dot(g0, x0), dot(g1, x1), dot(g2, x2), dot(g3, x3)));
}

vec3 safeNorm(vec3 v) {
    float l = length(v);
    return l > 1e-5 ? v / l : vec3(0.0, 0.0, -1.0);
}

vec3 getSky(vec3 rd) {
    float y = rd.y * 0.5 + 0.5;
    vec3 horizon = vec3(0.7, 0.8, 0.9);
    vec3 zenith = vec3(0.3, 0.5, 0.8);
    return mix(horizon, zenith, pow(y, 0.5));
}

vec3 getColor(int mat) {
    if (mat == MAT_GRASS) return vec3(0.3, 0.6, 0.2);
    if (mat == MAT_DIRT) return vec3(0.5, 0.35, 0.2);
    return vec3(0.5, 0.5, 0.5);
}

float fbm2D(vec2 p, int octaves) {
    float value = 0.0;
    float amp = 0.5;
    float freq = 1.0;
    for (int i = 0; i < octaves; i++) {
        value += amp * simplex3(vec3(p.x * freq, 0.0, p.y * freq));
        freq *= 2.0;
        amp *= 0.5;
    }
    return value;
}

float terrainHeight(vec2 p) {
    return fbm2D(p * 0.01, 5) * 50.0 + 20.0;
}

int cellType(ivec3 cell) {
    float h = terrainHeight(vec2(cell.x, cell.z));
    float depth = h - float(cell.y);
    if (depth < 0.0) return MAT_AIR;
    if (depth < 1.0) return MAT_GRASS;
    if (depth < 4.0) return MAT_DIRT;
    return MAT_STONE;
}

bool traceVoxel(vec3 ro, vec3 rd, out vec3 hitPos, out vec3 hitN, out float dist, out int mat) {
    ivec3 cell = ivec3(floor(ro));
    ivec3 istep = ivec3(rd.x > 0.0 ? 1 : -1, rd.y > 0.0 ? 1 : -1, rd.z > 0.0 ? 1 : -1);
    
    vec3 tDelta = vec3(1e30);
    vec3 tMax = vec3(1e30);
    
    if (abs(rd.x) > 1e-6) {
        tDelta.x = abs(1.0 / rd.x);
        tMax.x = (istep.x > 0) ? (float(cell.x + 1) - ro.x) / rd.x : (float(cell.x) - ro.x) / rd.x;
    }
    if (abs(rd.y) > 1e-6) {
        tDelta.y = abs(1.0 / rd.y);
        tMax.y = (istep.y > 0) ? (float(cell.y + 1) - ro.y) / rd.y : (float(cell.y) - ro.y) / rd.y;
    }
    if (abs(rd.z) > 1e-6) {
        tDelta.z = abs(1.0 / rd.z);
        tMax.z = (istep.z > 0) ? (float(cell.z + 1) - ro.z) / rd.z : (float(cell.z) - ro.z) / rd.z;
    }
    
    int lastAxis = -1;
    float tCur = 0.0;

    for (int i = 0; i < MAX_STEPS; ++i) {
        int idx = cellType(cell);
        if (idx >= 0) {
            if (lastAxis == 0) hitN = vec3(-float(istep.x), 0.0, 0.0);
            else if (lastAxis == 1) hitN = vec3(0.0, -float(istep.y), 0.0);
            else if (lastAxis == 2) hitN = vec3(0.0, 0.0, -float(istep.z));
            else hitN = -rd;
            hitPos = ro + rd * tCur;
            dist = tCur;
            mat = idx;
            return true;
        }

        if (tMax.x < tMax.y) {
            if (tMax.x < tMax.z) {
                tCur = tMax.x;
                tMax.x += tDelta.x;
                cell.x += istep.x;
                lastAxis = 0;
            } else {
                tCur = tMax.z;
                tMax.z += tDelta.z;
                cell.z += istep.z;
                lastAxis = 2;
            }
        } else {
            if (tMax.y < tMax.z) {
                tCur = tMax.y;
                tMax.y += tDelta.y;
                cell.y += istep.y;
                lastAxis = 1;
            } else {
                tCur = tMax.z;
                tMax.z += tDelta.z;
                cell.z += istep.z;
                lastAxis = 2;
            }
        }
        
        if (tCur > MAX_DIST) break;
    }
    return false;
}

vec3 shade(vec3 ro, vec3 rd, vec2 uv) {
    vec3 hitPos;
    vec3 hitN;
    float t;
    int m;
    vec3 sky = getSky(rd);
    if (!traceVoxel(ro, rd, hitPos, hitN, t, m)) return sky;
    vec3 lightDir = safeNorm(vec3(0.6, 0.9, 0.3));
    float diff = max(dot(hitN, lightDir), 0.0);
    vec3 base = getColor(m);
    float fog = exp(-t * 0.005);
    vec3 lit = base * (0.25 + 0.75 * diff);
    return mix(sky, lit, fog);
}

void main() {
    ivec2 fullSize = imageSize(destImage);
    ivec2 lowSize = fullSize / UPSCALE;
    ivec2 pixelLow = ivec2(gl_GlobalInvocationID.xy);
    if (pixelLow.x >= lowSize.x || pixelLow.y >= lowSize.y) return;

    vec2 uv = (vec2(pixelLow * UPSCALE) + 0.5 * float(UPSCALE)) / vec2(fullSize) * 2.0 - 1.0;

    float fov = camera.params.x;
    if (fov <= 0.0) fov = 1.0471976;
    float aspect = camera.params.y;
    if (aspect <= 0.0) aspect = float(fullSize.x) / float(fullSize.y);
    float tanHalfFov = tan(0.5 * fov);
    uv.x *= aspect;

    vec3 f = safeNorm(camera.camForward.xyz);
    vec3 r = safeNorm(camera.camRight.xyz);
    vec3 u = safeNorm(camera.camUp.xyz);
    r = -r;
    u = -u;

    vec3 rayDir = normalize(f + uv.x * tanHalfFov * r + uv.y * tanHalfFov * u);
    vec3 rayOrigin = camera.camPos.xyz;

    vec3 color = shade(rayOrigin, rayDir, uv);

    for (int oy = 0; oy < UPSCALE; ++oy) {
        for (int ox = 0; ox < UPSCALE; ++ox) {
            ivec2 dst = ivec2(pixelLow.x * UPSCALE + ox, pixelLow.y * UPSCALE + oy);
            if (dst.x < fullSize.x && dst.y < fullSize.y) {
                imageStore(destImage, dst, vec4(color, 1.0));
            }
        }
    }
}

