#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba8) uniform writeonly image2D destImage;

layout(std140, binding = 1) uniform Camera {
    vec4 camPos;
    vec4 camForward;
    vec4 camRight;
    vec4 camUp;
    vec4 params;
} camera;

const int UPSCALE = 2;

vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

float simplexNoise3(vec3 v) {
    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);
    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

    vec3 i = floor(v + dot(v, C.yyy));
    vec3 x0 = v - i + dot(i, C.xxx);

    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min(g.xyz, l.zxy);
    vec3 i2 = max(g.xyz, l.zxy);

    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy;
    vec3 x3 = x0 - D.yyy;

    i = mod289(i);
    vec4 p = permute(
        permute(
            permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) +
            i.y + vec4(0.0, i1.y, i2.y, 1.0)) +
        i.x + vec4(0.0, i1.x, i2.x, 1.0));

    float n_ = 0.142857142857;
    vec3 ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_);
    vec4 x = x_ * ns.x + ns.yyyy;
    vec4 y = y_ * ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);

    vec4 b0 = vec4(x.xy, y.xy);
    vec4 b1 = vec4(x.zw, y.zw);

    vec4 s0 = floor(b0) * 2.0 + 1.0;
    vec4 s1 = floor(b1) * 2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));

    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

    vec3 g0 = vec3(a0.xy, h.x);
    vec3 g1 = vec3(a0.zw, h.y);
    vec3 g2 = vec3(a1.xy, h.z);
    vec3 g3 = vec3(a1.zw, h.w);

    vec4 norm = taylorInvSqrt(vec4(dot(g0, g0), dot(g1, g1), dot(g2, g2), dot(g3, g3)));
    g0 *= norm.x;
    g1 *= norm.y;
    g2 *= norm.z;
    g3 *= norm.w;

    float m0 = max(0.6 - dot(x0, x0), 0.0);
    float m1 = max(0.6 - dot(x1, x1), 0.0);
    float m2 = max(0.6 - dot(x2, x2), 0.0);
    float m3 = max(0.6 - dot(x3, x3), 0.0);
    m0 *= m0;
    m1 *= m1;
    m2 *= m2;
    m3 *= m3;

    return 42.0 * (m0 * m0 * dot(g0, x0) +
                   m1 * m1 * dot(g1, x1) +
                   m2 * m2 * dot(g2, x2) +
                   m3 * m3 * dot(g3, x3));
}

float fractalNoise3D(vec3 p) {
    float value = 0.0;
    float amplitude = 1.0;
    float gain = 0.5;
    float lacunarity = 2.0;
    float frequency = 0.05;
    for (int i = 0; i < 5; ++i) {
        value += amplitude * simplexNoise3(p * frequency);
        frequency *= lacunarity;
        amplitude *= gain;
    }
    return value;
}

float baseWorldSDF(vec3 p) {
    float field = fractalNoise3D(p);
    return field;
}

void main() {
    ivec2 fullSize = imageSize(destImage);
    ivec2 lowSize = fullSize / UPSCALE;
    ivec2 pixelLow = ivec2(gl_GlobalInvocationID.xy);
    if (pixelLow.x >= lowSize.x || pixelLow.y >= lowSize.y) return;

    vec2 uv = (vec2(pixelLow * UPSCALE) + 0.5 * float(UPSCALE)) / vec2(fullSize) * 2.0 - 1.0;

    float fov = camera.params.x;
    if (fov <= 0.0) fov = 1.0471976;
    float aspect = camera.params.y;
    if (aspect <= 0.0) aspect = float(fullSize.x) / float(fullSize.y);
    float tanHalfFov = tan(0.5 * fov);
    uv.x *= aspect;

    vec3 f = camera.camForward.xyz;
    float lf = length(f);
    if (lf < 1e-4) f = normalize(vec3(0.0, -0.3, -1.0));
    else f /= lf;

    vec3 r = camera.camRight.xyz;
    float lr = length(r);
    if (lr < 1e-4) r = normalize(cross(f, vec3(0.0, 1.0, 0.0)));
    else r /= lr;

    vec3 u = camera.camUp.xyz;
    float lu = length(u);
    if (lu < 1e-4) u = normalize(cross(r, f));
    else u /= lu;

    r = -r;
    u = -u;

    vec3 camPos = camera.camPos.xyz;

    vec3 rayDir = normalize(f + uv.x * tanHalfFov * r + uv.y * tanHalfFov * u);

    float t = 0.0;
    const float MAX_DIST = 1000.0;
    const int MAX_STEPS = 160;
    const float HIT_EPS = 0.05;
    bool hit = false;
    vec3 p = camPos;

    for (int i = 0; i < MAX_STEPS; ++i) {
        p = camPos + rayDir * t;
        float d = baseWorldSDF(p);
        float ad = abs(d);
        if (ad < HIT_EPS) {
            hit = true;
            break;
        }
        float lod = clamp((t - 50.0) / (600.0 - 50.0), 0.0, 1.0);
        float stepScale = mix(1.0, 6.0, lod);
        float minStep = 0.02 * stepScale;
        t += max(ad * stepScale, minStep);
        if (t > MAX_DIST) break;
    }

    vec3 bg = vec3(0.05, 0.07, 0.1) + 0.4 * vec3(uv.y * 0.5 + 0.5);
    vec3 color = bg;

    if (hit) {
        vec3 pHit = p;
        float eps = 0.2;
        float d0 = baseWorldSDF(pHit);
        vec3 grad = vec3(
            baseWorldSDF(pHit + vec3(eps, 0.0, 0.0)) - baseWorldSDF(pHit - vec3(eps, 0.0, 0.0)),
            baseWorldSDF(pHit + vec3(0.0, eps, 0.0)) - baseWorldSDF(pHit - vec3(0.0, eps, 0.0)),
            baseWorldSDF(pHit + vec3(0.0, 0.0, eps)) - baseWorldSDF(pHit - vec3(0.0, 0.0, eps))
        );
        vec3 n = normalize(grad);

        vec3 lightDir = normalize(vec3(0.4, 0.8, 0.3));
        float diff = clamp(dot(n, lightDir), 0.0, 1.0);

        float h = clamp(pHit.y / 20.0, 0.0, 1.0);
        vec3 colLow = vec3(0.05, 0.12, 0.25);
        vec3 colMid = vec3(0.1, 0.45, 0.18);
        vec3 colHigh = vec3(0.7, 0.7, 0.7);
        vec3 baseCol = mix(colLow, colMid, smoothstep(0.0, 0.5, h));
        baseCol = mix(baseCol, colHigh, smoothstep(0.4, 1.0, h));

        float detail = 0.5 + 0.5 * fractalNoise3D(pHit * 1.5);
        baseCol *= mix(0.7, 1.3, detail);

        float depth = t / MAX_DIST;
        float fog = clamp(depth, 0.0, 1.0);

        vec3 lit = baseCol * (0.2 + 0.8 * diff);
        color = mix(lit, bg, fog);
    }

    for (int oy = 0; oy < UPSCALE; ++oy) {
        for (int ox = 0; ox < UPSCALE; ++ox) {
            ivec2 dst = ivec2(pixelLow.x * UPSCALE + ox, pixelLow.y * UPSCALE + oy);
            if (dst.x < fullSize.x && dst.y < fullSize.y) {
                imageStore(destImage, dst, vec4(color, 1.0));
            }
        }
    }
}


